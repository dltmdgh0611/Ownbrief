import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/backend/lib/auth'
import { prisma } from '@/backend/lib/prisma'
import { getYouTubeVideosFromPlaylists, getVideoDetails } from '@/backend/lib/youtube'
import { getVideoTranscript, combineTranscripts } from '@/backend/lib/subtitle'
import { generatePodcastScript, generateMultiSpeakerSpeech } from '@/backend/lib/gemini'
import { uploadAudioToStorage } from '@/backend/lib/supabase'

export const maxDuration = 300

export async function POST(request: NextRequest) {
  const logs: string[] = []
  
  const addLog = (message: string) => {
    console.log(message)
    logs.push(`[${new Date().toLocaleTimeString()}] ${message}`)
  }

  try {
    addLog('ğŸš€ ê°œë°œ ëª¨ë“œ: ìë™ íŒŸìºìŠ¤íŠ¸ ìƒì„± ì‹œì‘...')
    
    const session = await getServerSession(authOptions)
    
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized', logs }, { status: 401 })
    }

    const accessToken = (session as any)?.accessToken
    
    if (!accessToken) {
      return NextResponse.json({ error: 'No access token', logs }, { status: 401 })
    }

    addLog(`ğŸ‘¤ ì‚¬ìš©ì: ${session.user.email}`)

    // ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
      include: { userSettings: true, accounts: true }
    })

    if (!user) {
      addLog('âŒ ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤')
      return NextResponse.json({ error: 'ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', logs }, { status: 404 })
    }

    addLog(`âœ… ì‚¬ìš©ì ë°œê²¬: ${user.id}`)

    // í¬ë ˆë”§ í™•ì¸
    if (!user.userSettings || user.userSettings.credits <= 0) {
      addLog(`âš ï¸ í¬ë ˆë”§ ë¶€ì¡± (${user.userSettings?.credits || 0}ê°œ)`)
      return NextResponse.json({ 
        error: 'Insufficient credits',
        credits: user.userSettings?.credits || 0,
        logs 
      }, { status: 400 })
    }

    addLog(`ğŸ’° í˜„ì¬ í¬ë ˆë”§: ${user.userSettings.credits}ê°œ`)

    const selectedPlaylists = user.userSettings.selectedPlaylists || []

    if (selectedPlaylists.length === 0) {
      addLog('âš ï¸ ì„ íƒëœ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤')
      return NextResponse.json({ error: 'No playlists selected', logs }, { status: 400 })
    }

    addLog(`ğŸ“‹ ì„ íƒëœ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸: ${selectedPlaylists.length}ê°œ`)

    // íŒŸìºìŠ¤íŠ¸ ìƒì„± ì‹œì‘
    addLog('ğŸ¬ ìœ íŠœë¸Œ ì˜ìƒ ê°€ì ¸ì˜¤ëŠ” ì¤‘...')
    const playlistVideos = await getYouTubeVideosFromPlaylists(accessToken, selectedPlaylists)

    if (!playlistVideos || playlistVideos.length === 0) {
      addLog('âš ï¸ í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ì— ì˜ìƒì´ ì—†ìŠµë‹ˆë‹¤')
      return NextResponse.json({ error: 'No videos found', logs }, { status: 404 })
    }

    // ìµœì‹  5ê°œ ë™ì˜ìƒ
    const videoIds = playlistVideos
      .slice(0, 5)
      .map((video: any) => video.snippet?.resourceId?.videoId)
      .filter(Boolean)

    addLog(`ğŸ“¹ ${videoIds.length}ê°œ ì˜ìƒ ì„ íƒë¨`)

    const videoDetails = await getVideoDetails(videoIds, accessToken)
    addLog('âœ… ì˜ìƒ ìƒì„¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ')

    // ìë§‰ ì¶”ì¶œ
    addLog('ğŸ“ ìë§‰ ì¶”ì¶œ ì‹œì‘...')
    const transcripts = []
    for (let i = 0; i < videoIds.length; i++) {
      const videoId = videoIds[i]
      addLog(`  â”” ì˜ìƒ ${i + 1}/${videoIds.length}: ${videoId}`)
      try {
        const transcript = await getVideoTranscript(videoId!)
        transcripts.push(transcript)
        addLog(`    âœ… ${transcript.length}ê°œ ìë§‰ ì„¸ê·¸ë¨¼íŠ¸ ì¶”ì¶œ`)
        await new Promise((resolve) => setTimeout(resolve, 2000))
      } catch (error: any) {
        addLog(`    âŒ ìë§‰ ì¶”ì¶œ ì‹¤íŒ¨: ${error.message}`)
        transcripts.push([])
      }
    }

    const combinedTranscript = combineTranscripts(transcripts.filter((t: any) => t.length > 0))

    if (!combinedTranscript || combinedTranscript.trim().length === 0) {
      addLog('âš ï¸ ì¶”ì¶œëœ ìë§‰ì´ ì—†ìŠµë‹ˆë‹¤')
      return NextResponse.json({ error: 'No subtitles extracted', logs }, { status: 400 })
    }

    addLog(`âœ… ì´ ${combinedTranscript.length}ì ìë§‰ ì¶”ì¶œ ì™„ë£Œ`)

    // ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
    addLog('âœï¸ AI ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ì¤‘...')
    const script = await generatePodcastScript(combinedTranscript)
    addLog(`âœ… ${script.length}ì ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ì™„ë£Œ`)

    // ê³µê°œ ì‹œê°„: í˜„ì¬ ì‹œê°„ + 1ë¶„
    const publishedAt = new Date(Date.now() + 60 * 1000)
    addLog(`â° ê³µê°œ ì˜ˆì • ì‹œê°„: ${publishedAt.toLocaleString('ko-KR')}`)

    // íŒŸìºìŠ¤íŠ¸ ë ˆì½”ë“œ ìƒì„±
    addLog('ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ ì¤‘...')
    const podcast = await prisma.podcast.create({
      data: {
        title: `AI Cast - ${new Date().toLocaleDateString('ko-KR')}`,
        description: `Podcast generated from ${videoIds.length} videos`,
        script: script,
        userId: user.id,
        status: 'processing',
        isAutoGenerated: true,
        publishedAt: publishedAt,
      },
    })

    addLog(`âœ… íŒŸìºìŠ¤íŠ¸ ìƒì„±: ${podcast.id}`)

    // ìŒì„± ìƒì„±
    addLog('ğŸ¤ AI ìŒì„± ìƒì„± ì¤‘ (ì‹œê°„ì´ ì†Œìš”ë©ë‹ˆë‹¤)...')
    const audioResult = await generateMultiSpeakerSpeech(script)
    addLog(`âœ… ìŒì„± ìƒì„± ì™„ë£Œ (${audioResult.buffer.length} bytes)`)

    // íŒŒì¼ í™•ì¥ì ê²°ì •
    let fileExtension = 'wav'
    if (audioResult.mimeType.includes('mpeg') || audioResult.mimeType.includes('mp3')) {
      fileExtension = 'mp3'
    } else if (audioResult.mimeType.includes('wav')) {
      fileExtension = 'wav'
    } else if (audioResult.mimeType.includes('ogg')) {
      fileExtension = 'ogg'
    }

    const audioFileName = `podcast-${podcast.id}.${fileExtension}`
    addLog(`ğŸ“¤ Supabase Storageì— ì—…ë¡œë“œ ì¤‘: ${audioFileName}`)

    // Supabase Storageì— ì—…ë¡œë“œ
    const publicUrl = await uploadAudioToStorage(audioResult.buffer, audioFileName, audioResult.mimeType)
    addLog(`âœ… ì—…ë¡œë“œ ì™„ë£Œ: ${publicUrl}`)

    // Duration ê³„ì‚°
    let duration = 0
    if (fileExtension === 'wav' && audioResult.buffer.length > 44) {
      const sampleRate = audioResult.buffer.readUInt32LE(24)
      const byteRate = audioResult.buffer.readUInt32LE(28)
      const dataSize = audioResult.buffer.readUInt32LE(40)
      duration = Math.floor(dataSize / byteRate)
      addLog(`â±ï¸ íŒŸìºìŠ¤íŠ¸ ê¸¸ì´: ${Math.floor(duration / 60)}ë¶„ ${duration % 60}ì´ˆ`)
    }

    // íŒŸìºìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
    addLog('ğŸ”„ íŒŸìºìŠ¤íŠ¸ ìƒíƒœ ì—…ë°ì´íŠ¸ ì¤‘...')
    await prisma.podcast.update({
      where: { id: podcast.id },
      data: {
        status: 'completed',
        audioUrl: publicUrl,
        duration,
      },
    })

    // í¬ë ˆë”§ ì°¨ê°
    addLog('ğŸ’³ í¬ë ˆë”§ ì°¨ê° ì¤‘...')
    await prisma.userSettings.update({
      where: { userId: user.id },
      data: {
        credits: user.userSettings.credits - 1,
      },
    })

    const remainingCredits = user.userSettings.credits - 1
    addLog(`âœ… í¬ë ˆë”§ ì°¨ê° ì™„ë£Œ. ë‚¨ì€ í¬ë ˆë”§: ${remainingCredits}ê°œ`)

    addLog('ğŸ‰ íŒŸìºìŠ¤íŠ¸ ìë™ ìƒì„± ì™„ë£Œ!')
    addLog(`ğŸ“ íŒŸìºìŠ¤íŠ¸ ID: ${podcast.id}`)
    addLog(`ğŸ• ê³µê°œê¹Œì§€ ë‚¨ì€ ì‹œê°„: ì•½ 1ë¶„`)

    return NextResponse.json({
      success: true,
      podcastId: podcast.id,
      publishedAt: publishedAt.toISOString(),
      remainingCredits,
      logs,
    })
  } catch (error: any) {
    addLog(`âŒ ì˜¤ë¥˜ ë°œìƒ: ${error.message}`)
    console.error('Test auto-generate error:', error)
    return NextResponse.json({ 
      error: error.message,
      logs 
    }, { status: 500 })
  }
}

